"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для первого скрипта
"""

"""Обычный класс и класс со слотами"""

'''
Функция sys.getsizeof возвращает размер переданного ей обьекта, 
этот размер не включает в себя сложные структуры классов и т.д.
Функция pympler.asizeof - рекурсивно ищет все вложенные 
поля и элементы, и отображает общий размер обьекта
'''

from pympler import asizeof


# Task 9_2.
# Реализовать класс Road (дорога).
# Техническое задание:
#
# определить атрибуты: length (длина), width (ширина). Подумайте атрибуты чего?
# значения атрибутов должны передаваться при создании экземпляра класса
# атрибуты сделать защищёнными
# определить метод расчёта массы асфальта, необходимого для покрытия всей дороги
# метод возвращает массу асфальта в виде строки в требуемом формате (см примеры/тесты)
# формула 'длина * ширина * масса асфальта для покрытия одного кв. метра дороги асфальтом, ' \
#         'толщиной в 1 см * число см толщины полотна';
# проверить работу метода и вывести массу асфальта для 2-3 наборов параметров.

class Road:

    def __init__(self, length, width):
        self._length = length
        self._width = width

    def calc_mass(self):
        mass = f'{int(self._length * self._width * 25 * 5 / 1000)} т'
        return mass


BC_OBJ = Road(20, 5000)
print(asizeof.asizeof((BC_OBJ)))  # -> 328


class Road:
    __slots__ = ['_length', '_width']

    def __init__(self, length, width):
        self._length = length
        self._width = width

    def calc_mass(self):
        mass = f'{int(self._length * self._width * 25 * 5 / 1000)} т'
        return mass


BC_OBJ = Road(20, 5000)
print(asizeof.asizeof(BC_OBJ))  # -> 112

# В этой задаче используется оптимизацию с помощью конструкции __slots__ (Способ 2. Слоты в ООП), это позволило
# уменьшить память, потребляемую экземплярами класса

"""
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для второго скрипта
"""

'''
Дан список, содержащий искажённые данные с должностями и именами сотрудников:
['инженер-конструктор Игорь', 'главный бухгалтер МАРИНА', 'токарь высшего разряда нИКОЛАй', 'директор аэлита']
Известно, что имя сотрудника всегда в конце строки. Сформировать и вывести на экран фразы вида: 'Привет, Игорь!'
Подумать, как получить имена сотрудников из элементов списка, как привести их к корректному виду.
Можно ли при этом не создавать новый список?
'''

from sys import getsizeof

staff = ['инженер-конструктор Игорь', 'главный бухгалтер МАРИНА', 'токарь высшего разряда нИКОЛАй', 'директор аэлита']

for employee in staff:
    print('Привет,', f'{employee.split()[-1].title()}!')
print(getsizeof(staff), 'байт')  # -> 120 байт


staff = ('инженер-конструктор Игорь', 'главный бухгалтер МАРИНА', 'токарь высшего разряда нИКОЛАй', 'директор аэлита')

for employee in staff:
    print('Привет,', f'{employee.split()[-1].title()}!')

print(getsizeof(staff), 'байт')  # -> 72 байт

'''
Переход от списка к кортежу позволяет сэкономить немного памяти.
'''

"""
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для третьего скрипта
"""


"""
Реализовать базовый класс Worker (работник):
определить атрибуты: name, surname, position (должность), income (доход);
последний атрибут должен быть защищённым и ссылаться на словарь, содержащий элементы «оклад» и «премия», например, {"wage": wage, "bonus": bonus};
создать класс Position (должность) на базе класса Worker;
в классе Position реализовать методы получения полного имени сотрудника (get_full_name) и дохода с учётом премии (get_total_income);
проверить работу примера на реальных данных: создать экземпляры класса Position, передать данные, проверить значения атрибутов, вызвать методы экземпляров.
"""

# Исходный вариант

from sys import getsizeof


class Worker:
    def __init__(self, name: str, surname: str, position: str, income: dict):
        self.name = name
        self.surname = surname
        self.position = position
        self.income = income


class Position(Worker):
    def get_full_name(self) -> str:
        """Возвращает строку по формату 'Имя Фамилия'"""
        self.full_name = f'{self.name.title()} {self.surname.title()}'
        return self.full_name

    def get_total_income(self) -> int:
        """Возвращает суммарный ежемесячных доход"""
        self.result = f'{sum(self.income.values())}'
        return self.result


if __name__ == '__main__':
    welder = Position('иван', 'васильев', 'сварщик', {
                      'wage': 50000, 'bonus': 15000})
    driver = Position('сергей', 'николаев', 'водитель',
                      {'wage': 30000, 'bonus': 7500})
    scientist = Position('геннадий', 'геннадьевич', 'ученый',
                         {'wage': 150000, 'bonus': 25000})
    # Иван Васильев 65000
    print(welder.get_full_name(), welder.get_total_income())
    # Петр Николаев 37500
    print(driver.get_full_name(), driver.get_total_income())
    # Геннадий Разумов 175000
    print(scientist.get_full_name(), scientist.get_total_income())
    print(getsizeof(welder))

# Оптимизированный через __slots__

class WorkerNew:
    def __init__(self, name: str, surname: str, position: str, income: dict):
        self.name = name
        self.surname = surname
        self.position = position
        self.income = income


class PositionNew(Worker):
    __slots__ = ('name', 'surname', 'position', 'income', 'result')

    def get_full_name(self) -> str:
        """Возвращает строку по формату 'Имя Фамилия'"""
        self.full_name = f'{self.name.title()} {self.surname.title()}'
        return self.full_name

    def get_total_income(self) -> int:
        """Возвращает суммарный ежемесячных доход"""
        self.result = f'{sum(self.income.values())}'
        return self.result


if __name__ == '__main__':
    welder = PositionNew('иван', 'васильев', 'сварщик', {
        'wage': 50000, 'bonus': 15000})
    driver = PositionNew('сергей', 'николаев', 'водитель',
                         {'wage': 30000, 'bonus': 7500})
    scientist = PositionNew('геннадий', 'геннадьевич', 'ученый',
                            {'wage': 150000, 'bonus': 25000})
    print(welder.get_full_name(), welder.get_total_income())
    print(driver.get_full_name(), driver.get_total_income())
    print(scientist.get_full_name(), scientist.get_total_income())
    print(getsizeof(welder))

'''
Добавление слотов в наследованный класс, снизило потребление памяти
1-й вариант = 88
2-ой вариант = 48
'''


"""
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для четвертого скрипта
"""


from memory_profiler import profile
import numpy as np
from random import randint
from timeit import timeit


# Вариант с list
@profile
def list_append():
    my_list = []
    for i in range(100000):
        my_list.append(randint(1, 1000))


# Вариант с numpy array
@profile
def array_append():
    my_array = np.array([])
    for i in range(100000):
        np.append(my_array, randint(1, 1000))


print(timeit("list_append()", setup="from __main__ import list_append", number=1))
print(timeit("array_append()", setup="from __main__ import array_append", number=1))

'''
Массивы numpy занимают меньше места в памяти, но при этом заполняются медленнее, чем списки
Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    41     31.0 MiB     31.0 MiB           1   @profile
    42                                         def list_append():
    43     31.0 MiB      0.0 MiB           1       my_list = []
    44     34.2 MiB      2.3 MiB      100001       for i in range(100000):
    45     34.2 MiB      0.9 MiB      100000           my_list.append(randint(1, 1000))
12.994985799989081
Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    49     33.2 MiB     33.2 MiB           1   @profile
    50                                         def array_append():
    51     33.2 MiB      0.0 MiB           1       my_array = np.array([])
    52     33.2 MiB      0.0 MiB      100001       for i in range(100000):
    53     33.2 MiB      0.0 MiB      100000           np.append(my_array, randint(1, 1000))
20.88992390000203
'''

"""
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для пятого скрипта
"""


from sys import getsizeof


# ИСХОДНОЕ:
class Matrix:

    def __init__(self, some_list):
        self.some_list = some_list

    def __str__(self):
        for el in self.some_list:
            print('|', end=' ')
            for i in el:
                print(f'{i}', end=' ')
            print('|')
        return

    def __add__(self, other):
        res = self.some_list.copy()
        for i in range(len(self.some_list)):
            if len(self.some_list) != len(other.some_list):
                print(f'Списки разной длины. Проверьте.')
                exit(code=1)
            for j in range(len(self.some_list[i])):
                if len(self.some_list[i]) != len(other.some_list[i]):
                    print(f'Списки разной длины. Проверьте.')
                    exit(code=1)
                res[i][j] = self.some_list[i][j] + other.some_list[i][j]
        return res


# ОПТИМИЗИРОВАННОЕ:
class Matrix2:
    __slots__ = 'some_list'

    def __init__(self, some_list):
        self.some_list = some_list

    def __str__(self):
        for el in self.some_list:
            print('|', end=' ')
            for i in el:
                print(f'{i}', end=' ')
            print('|')
        return

    def __add__(self, other):
        res = self.some_list.copy()
        for i in range(len(self.some_list)):
            if len(self.some_list) != len(other.some_list):
                print(f'Списки разной длины. Проверьте.')
                exit(code=1)
            for j in range(len(self.some_list[i])):
                if len(self.some_list[i]) != len(other.some_list[i]):
                    print(f'Списки разной длины. Проверьте.')
                    exit(code=1)
                res[i][j] = self.some_list[i][j] + other.some_list[i][j]
        return res


f_list = [[31, 22], [37, 43], [51, 86], [3, 5, 32], [2, 4, 6], [-1, 64, -8], [3, 5, 8, 3], [8, 3, 7, 1]]
s_list = [[31, 22], [37, 43], [51, 86], [3, 5, 32], [2, 4, 6], [-1, 64, -8], [3, 5, 8, 3], [8, 3, 7, 1]]

# До
first_el = Matrix(f_list)
second_el = Matrix(s_list)
result_list = first_el + second_el
result = Matrix(result_list)
print(getsizeof(result))

# После
first_el = Matrix2(f_list)
second_el = Matrix2(s_list)
result_list = first_el + second_el
result = Matrix2(result_list)
print(getsizeof(result))

'''
48
40
Вывод:
Использование слотов позволяет экономить память при использовании ООП.
'''


"""
Задание 2.
Попытайтесь выполнить профилирование памяти в любом скрипте с рекурсией.
Вам нужно обнаружить проблему в процессе этого. Но проблема связана не с тем,
что рекурсия потребляет много памяти, а с самим процессом замеров.
Опищите эту проблему и найдите простой путь ее решения.
Опишите этот путь и покажите его применение
"""


from memory_profiler import profile


def prove_equality(n, total=0):
    if n < 1:
        return total
    else:
        total += n
    return prove_equality(n - 1, total)


@profile
def main(n):
    return n


n = 500
if __name__ == '__main__':
    print(main(prove_equality(n)))
    # prove_equality(n)
    print(prove_equality(n) == n * (n + 1) / 2)

'''
При каждом вызове рекурсии вызывается профайлер, в результате мы не видим общего значения потребления памяти.
Чтобы видеть реальный результат нужно делать декоратор или вызывать из другой функции
'''