""" 
Задание 1. 
Для каждой из трех функций выполнить следующее: 
1) для каждого выражения вместо символов !!! укажите сложность. 
2) определите сложность алгоритма в целом (Сложность: !!!). 
Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ! 
-- Сложность нужно указать только там, где есть !!! 
-- Сложности встроенных функций и операций нужно искать 
    в таблицах (см. материалы к уроку). 
""" 
 
from random import sample 
 
 
############################################################################## 
def check_1(lst_obj): 
    """Функция должна создать множество из списка. 
    Алгоритм 1: 
    Создать множество из списка 
    Сложность: O(n). 
    """ 
    lst_to_set = set(lst_obj)  # O(n) - линейная сложность 
    return lst_to_set  # O(1) - константная сложность


""" 
Задание 2. 
Реализуйте два алгоритма. 
Оба должны обеспечивать поиск минимального значения для списка. 
Сложность первого алгоритма должна быть O(n^2) - квадратичная. 
Сложность второго алгоритма должна быть O(n) - линейная. 
Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ! 
-- нельзя использовать встроенные функции min() и sort() 
-- каждый из двух алгоритмов нужно оформить в виде отдельной ф-ции 
-- проставьте сложности каждого выражения в двух ваших алгоритмах 
""" 
 
# Квадратичная сложность алгоритма O(n^2) 
 
from random import randint 
 
 
def list_min(lst_): 
    for i in lst_:           # O(n) 
        min_ = i             # O(1) 
        for c in lst_:       # O(n) 
            if c < min_:     # O(1) 
                min_ = c     # O(1) 
    return min_              # O(1) 
 
 
# Линейная сложность алгоритма O(n) 
 
 
def list_min_2(lst_): 
    min_2 = lst_[0]      # O(1) 
    for i in lst_:       # O(n) 
        if i < min_2:    # O(1) 
            min_2 = i    # O(1) 
    return min_2         # O(1) 
 
 
lst_ = [randint(0, 100) for i in range(20)] 
print(lst_) 
print(list_min(lst_)) 
print(list_min_2(lst_))


""" 
Задание 3. 
Для этой задачи 
1) придумайте 2-3 решения (обязательно с различной сложностью) 
2) оцените сложность каждого выражения в этих решениях в нотации О-большое 
3) оцените итоговую сложность каждого решения в нотации О-большое 
3) сделайте вывод, какое решение эффективнее и почему 
Сама задача: 
Имеется хранилище с информацией о компаниях: название и годовая прибыль. 
Для реализации хранилища можно применить любой подход, 
который вы придумаете, например, реализовать словарь. 
Реализуйте поиск трех компаний с наибольшей годовой прибылью. 
Выведите результат. 
Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ! 
""" 
 
сompany_revenue = { 
    'activision': 8100000, 
    'netease': 9600000, 
    'nintendo': 8080000, 
    'microsoft': 1290000, 
    'google': 11000000, 
    'apple': 15300000, 
    'tencent': 32200000, 
    'sony': 18200000, 
} 
 
 
# Первый вариант - O(n log n) 
def sorted_1(сompany_revenue): 
    company = сompany_revenue.items() 
    company = sorted(company, key=lambda x: x[1]) 
    print(company[-1], company[-2], company[-3]) 
 
 
# Второй вариант - O(n) 
def sorted_2(сompany_revenue): 
    input_max = {} 
    list_d = dict(сompany_revenue) 
    for i in range(3): 
        maximum = max(list_d.items(), key=lambda k_v: k_v[1]) 
        del list_d[maximum[0]] 
        input_max[maximum[0]] = maximum[1] 
    print(input_max) 
 
 
sorted_1(сompany_revenue) 
sorted_2(сompany_revenue)




""" 
Задание 4. 
Для этой задачи: 
1) придумайте 2-3 решения (обязательно с различной сложностью) 
2) оцените сложность каждого выражения в этих решениях в нотации О-большое 
3) оцените итоговую сложность каждого решения в нотации О-большое 
4) сделайте вывод, какое решение эффективнее и почему 
Сама задача: 
Пользователи веб-ресурса проходят аутентификацию. 
В системе хранятся логин, пароль и отметка об активации учетной записи. 
Нужно реализовать проверку, может ли пользователь быть допущен к ресурсу. 
При этом его учетка должна быть активирована. 
А если нет, то польз-лю нужно предложить ее пройти. 
Приложение должно давать ответы на эти вопросы 
 и быть реализовано в виде функции. 
Для реализации хранилища можно применить любой подход, 
который вы придумаете, например, применить словарь. 
Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ! 
""" 
 
activated = True 
not_activated = False 
users = {"abcdefg123123": ["dsjkfs345", activated], 
         "i_zaycev": ["jhhjg1919", activated], 
         "n_nikolayev": ["jsdha34jsfd", not_activated], 
         "a_antonova": ["hsdfjs12", activated], 
         "123456ertyui": ["asfgd769", activated] 
         } 
 
 
# O(n) 
def check_activation(lst): 
    for k, v in lst.items():  # O(n) 
        if v[1] == activated:  # O(1) 
            print("Access granted.")  # O(1) 
        else: 
            print(f"Access denied. Dear {k}, please, activate your account.")  # O(1) 
 
 
check_activation(users)




""" 
Задание 5. На закрепление навыков работы со стеком 
Реализуйте собственный класс-структуру "стопка тарелок". 
Мы можем складывать тарелки в стопку и при превышении некоторого значения 
нужно начать складывать тарелки в новую стопку. 
Структура должна предусматривать наличие нескольких стопок. 
Создание новой стопки происходит при достижении предыдущим 
стеком порогового значения. 
После реализации структуры, проверьте ее работу на различных сценариях. 
Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ! 
--реализуйте по аналогии с примером, рассмотренным на уроке 
--создание нового стопки можно реализовать добавлением нового пустого массива 
в массив стопок (lst = [[], [], [], [],....]). 
""" 
 
class StackClass: 
    def __init__(self, max_size): 
        self.elems = [[]] 
        self.max_size = max_size 
    def push_in(self, el): 
        if len(self.elems[len(self.elems) - 1]) < self.max_size: 
            self.elems[len(self.elems) - 1].append(el) 
        else: 
            self.elems.append([]) 
            self.elems[len(self.elems) - 1].append(el) 
    def pop_out(self): 
        if len(self.elems[len(self.elems) - 1]) == 0: 
            self.elems.pop() 
        return self.elems[-1].pop() 
 
    def get_val(self): 
        return self.elems[len(self.elems) - 1] 
 
    def stack_size(self): 
        return len(self.elems) 
 
if __name__ == '__main__': 
    stack_1 = StackClass(2) 
    stack_1.push_in(1) 
    stack_1.push_in(2) 
    stack_1.push_in(3) 
    stack_1.push_in(4) 
    stack_1.push_in(5) 
    stack_1.push_in(6) 
    stack_1.pop_out() 
    stack_1.pop_out() 
    stack_1.pop_out() 
    stack_1.pop_out() 
    stack_1.pop_out() 
    print(stack_1.elems)